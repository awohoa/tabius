import { a } from "./ToastContext";

const S={grey:"#E0E0E0",blue:"#82B1FF",red:"#E57373",yellow:"#FFF176",green:"#81C784",pink:"#FF80AB",purple:"#EA80FC",cyan:"#84FFFF",orange:"#FC9B51"},L=["chrome://","chrome-extension://","edge://","extensions://"];async function i(e){try{return chrome.storage.sync.get(e)}catch{}}async function A(e){return chrome.storage.sync.get([...e])}const O=`Please put the website URL in this format: "https://somewebsite.com"
					or "http://sub.domain.com" without the quotes. Note: only the origin
					part of the URL (https://www.domain.com) is considered when
					blacklisting. The rules are applicable when you open new tabs from
					these websites - in other words - when they are the{" "}
					original tab. The rules are also subdomain sensitive,
					meaning "https://en.wikipedia.com" is treated differently than
					"https://wikipedia.com".`,H=`Please put the website URL in this format: "https://somewebsite.com"
					or "http://sub.domain.com" without the quotes. Note: only the origin
					part of the URL (https://www.domain.com) is considered. The rules are
					applicable when you open new tabs from these websites - in other words
					- when they are the
					original tab. The rules are also
					subdomain sensitive, meaning "https://www.wikipedia.com" is
					treated differently than "https://wikipedia.com". Please ensure the URL is correct. Duplicate entries
					will be ignored.`,T=`
████████╗ █████╗ ██████╗ ██╗██╗   ██╗███████╗    ██████╗     ██████╗ 
╚══██╔══╝██╔══██╗██╔══██╗██║██║   ██║██╔════╝    ╚════██╗   ██╔═████╗
   ██║   ███████║██████╔╝██║██║   ██║███████╗     █████╔╝   ██║██╔██║
   ██║   ██╔══██║██╔══██╗██║██║   ██║╚════██║    ██╔═══╝    ████╔╝██║
   ██║   ██║  ██║██████╔╝██║╚██████╔╝███████║    ███████╗██╗╚██████╔╝
   ╚═╝   ╚═╝  ╚═╝╚═════╝ ╚═╝ ╚═════╝ ╚══════╝    ╚══════╝╚═╝ ╚═════╝ 
                                                                     
`;function p(e){return e?L.some(t=>e.includes(t)):!1}function G(){return crypto.randomUUID()}function R(e){let t;try{t=new URL(e)}catch{return!1}return t.protocol==="https:"||t.protocol==="http:"}async function P(e){if(!e)return!1;const t=G();if(!R(e))return!1;let a=new URL(e).origin;if(!a)return!1;try{const{blocklist:s}=await i("blocklist"),n={id:t,blockedUrl:a};let o=[...s,n];return chrome.storage.sync.set({blocklist:o}),!0}catch{return!1}}async function _(e){if(!e)return!1;try{const{blocklist:t}=await i("blocklist"); a=t==null?void 0:T.filter(s=> u(s.blockedUrl) !== u(e)); await chrome.storage.sync.set({blocklist: a}); console.log("Rule deleted for URL:", e); return !0;} catch(error) { console.error("Error deleting rule:", error); return !1;} } function j(e){const t={url:e.url,active:!1};chrome.tabs.create(t)}chrome.tabs.onCreated.addListener(async e=>await y(e));function g(e){e&&chrome.tabs.ungroup(e,()=>{})}async function y(e){if(!e.id)return;const t=await chrome.tabs.get(e.id);let a=!1,s=!0,n=!1;const o={tabIds:[t.id,t.openerTabId]};let r;if(t.openerTabId&&(r=await chrome.tabs.get(t==null?void 0:t.openerTabId),r.pinned))return;if(await E(r==null?void 0:r.url)){try{g(t.id)}catch{}return}(r==null?void 0:r.groupId)!==-1&&(o.groupId=r==null?void 0:r.groupId,s=!1);const l=await i("maximum");l!=null&&l.maximum&&parseInt(l.maximum)>1&&(s||await I(r==null?void 0:r.groupId)>parseInt(l.maximum)&&(n=!0,g(t.id)));try{if((t.url||t.pendingUrl)&&!p(t.pendingUrl??t.url)&&!p(r==null?void 0:r.url)&&!n){const c=await i("groupby"),U=r==null?void 0:r.url,k=t.pendingUrl??t.url;if((c==null?void 0:c.groupby)==="sd"&&u(U)!==u(k)&&(a=!0),a){const d=await i("regardless");(d==null?void 0:d.regardless)!==!0&&g(t.id);return}const b=await chrome.tabs.group(o);if(!(await chrome.tabGroups.get(b)).title){const d=await v(r==null?void 0:r.url);let h,f,w;d?(h=d.alias,f=d.color):h=await q((r==null?void 0:r.pendingUrl)??(r==null?void 0:r.url),r),f?w={title:h,color:f}:w={title:h};try{const F=await chrome.tabGroups.update(b,w)}catch{}}}}catch(c){c=="Error: Tabs cannot be edited right now (user may be dragging a tab)."&&setTimeout(()=>y(t),50)}}async function q(e,t){if(!e)return;const a=new URL(e).hostname,s=a.split("."),n=await i("naming");switch(n==null?void 0:n.naming){case"dom":return o();case"subdom":return s.length>2?s[0]+"."+s[1]:s[0];case"subdomtld":return a;case"nameless":return"";case"title":return t!=null&&t.title?N(t):o();default:return o()}function o(){return s.length>2?s[1]:s[0]}}function N(e){return e.title}function u(e){if(e)return new URL(e).hostname}async function v(e){var t;if(!e)return!1;try{const a=await i("customrules");return(t=a==null?void 0:a.customrules)==null?void 0:t.find(n=>u(n.url)===u(e))}catch{return!1}}async function E(e){var t;if(!e)return!1;try{const a=await i("blocklist");return(t=a==null?void 0:a.blocklist)==null?void 0:t.find(n=>u(n.blockedUrl)===u(e))}catch{return!1}}async function I(e){if(!e)return 0;const t={groupId:e};return(await chrome.tabs.query(t)).length}chrome.tabs.onRemoved.addListener(async(e,t)=>{const a=await i("lonely");if(!(a!=null&&a.lonely))return;const s={windowId:-2};(await chrome.tabGroups.query(s)).forEach(async o=>{await x(o.id)})});async function x(e){const t={groupId:e},a=await chrome.tabs.query(t);if(a.length===1){const s=a[0].id;return s&&await chrome.tabs.ungroup(s),!0}return!1}chrome.tabs.onActivated.addListener(async e=>{const t=await i("autocollapse");if(!(t!=null&&t.autocollapse))return;const s=(await B()).groupId,n={windowId:-2},o=await chrome.tabGroups.query(n);for(const r of o){if(r.id===s||r.collapsed)continue;const m=r.id,l={collapsed:!0};try{await chrome.tabGroups.update(m,l)}catch(c){c=="Error: Tabs cannot be edited right now (user may be dragging a tab)."&&setTimeout(()=>C(m),200)}}});async function C(e){const t={collapsed:!0};await chrome.tabGroups.update(e,t)}async function B(){let e={active:!0,lastFocusedWindow:!0},[t]=await chrome.tabs.query(e);return t}export{S as C,P as a,G as b,H as c,_ as d,R as e,O as f,i as g,A as h,p as i,j as r,T as t,E as w};
